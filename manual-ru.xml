<?xml version="1.0" encoding="utf-8"?>
<manual>

    <item search="c">
        <p>Самое простое выражение - искать конкретную букву или слово в тексте. Он работает, как обычный «Поиск».</p>
        <p>Например, если вы ищете букву «d», регулярное выражение будет искать эту же букву «d». Если мы ищем слово «привет», выражение будет «привет». Всё просто.</p>
    </item>
    <item search=".">
        <p>Точка в регулярном выражении определяет любой символ (число, буква, специальный символ).</p>

        <p>Если мы ищем любой символ, за которым следует буква a, например «5a», «da», «@a», шаблон будет следующим «.a».</p>

        <p>Это выражение дает многое другим, таким как группы или кванторы. Например, если мы хотим найти любые 5 символов, мы могли бы использовать «. {5}».</p>
    </item>
    <item>
        <searches>
            <search element="\\w" />
            <search element="\\d" />
            <search element="\\s" />
        </searches>
        <p>Регулярные выражения «{line}w», «{line}d», «{line}s» определяют любую букву, любую цифру или пробел соответственно.</p>

        <p>Подобно точке можно определить другие выражения (группы, кванторы). Например, чтобы найти две буквы, за которыми следует пробел и число (например, «aB 3»), мы могли бы использовать это регулярное выражение «{line}w{2}{line}s{line}d"</p>

    </item>

    <item>
        <searches>
            <search element="\\W" />
            <search element="\\D" />
            <search element="\\S" />
        </searches>
        <p>Регулярные выражения «{line}W», «{line}D», «{line}S» определяют шаблон, в котором НЕ найдена буква, цифра или пробел.</p>

        <p>То есть он работает следующим образом, если мы ищем какой-либо символ, кроме пространства, мы могли бы использовать «{line}S».</p>

        <p>Например, давайте посмотрим на текст «5Q @». (Любой символ без пробела), мы могли бы использовать {line}S {4}.</p>

    </item>

    <item search="[abc]">
        <p>Это выражение находит любое совпадение, которое находится внутри набора.</p>
        <p>Таким образом, выражение [bcd] находит тексты «b», «c» или «d».</p>

        <p>Вы также можете использовать выражения внутри, например [{line}w {line}d- @], вы найдете алфавитно-цифровой символ, дефис или символ «@».</p>

        <p>Как и предыдущие выражения, можно сгруппировать или использовать квантификаторы.</p>

        <p>Особое использование наборов - это диапазоны, позволяющие указать число или букву, с которой вы начинаете, и последнее. Например, [A-Z] найдет любую букву между «A» и «Z». (Для нижнего регистра вы можете использовать [a-z].</p>

        <p>Например, для поиска букв между «r» и «u» и между «c» и «e» вы можете использовать «[r-uc-e]».</p>

    </item>
    <item search="[^abc]">
        <p>Это отрицание множества, т. е. Если [abc] найдено совпадение с «a», «b» или «c». Отложенный набор [^abc] найдет любой символ, отличный от «a», «b», «c».</p>

        <p>Все установленные правила работают в отказе.</p>

    </item>
    <item>
        <searches>
            <search element="^" />
            <search element="$" />
        </searches>
        <p>Выражения «^» и «$» служат для обозначения начала и конца строки. Например, при поиске шаблона «a» вы найдете все буквы «a» в тексте, однако поиск «a$» найдет последнюю букву строки, если это a.</p>

        <p>"5a" (строка, начинающаяся с номера) -> "^{line}d"</p>
    </item>

    <item search="\\b">
        <p>Выражение {line}b используется для обозначения невидимого символа в качестве начала и конца строки или пробелов.</p>
        <p>Например: </p>
        <p>Для выражения «{line}bye{line}b» вы найдете текст «ye», но не текст «bye», так как b не соответствует пробелу, началу или концу строки.</p>

    </item>

    <item search="\\B">
        <p>Выражение {line}B используется для обозначения неграничного слова (видимого символа)</p>
        <p>Например: </p>
        <p>Для выражения «{line}Bye» вы найдете текст «bye», но не текст «ye», поскольку перед ним есть невидимый символ (начало строки)</p>

    </item>

    <item search="\\.">
        <p>Когда мы хотим найти символ, зарезервированный с помощью регулярного выражения, мы используем экранированный символ «{line}».</p>

        <p>Например, если мы хотим найти точку в конце текста, мы НЕ можем использовать «.$», Поскольку точка представляет любой символ. Таким образом, мы использовали символ Escaped, таким образом он будет выглядеть как «{line}.$».</p>

        <p>Например, если я хочу найти текст «{line}w», я бы использовал выражение «{line}{line}w».</p>

    </item>
    <item search="(abc)">
        <p>Вы можете группировать спички для вариантов замены или других утилит.</p>

        <p>Например, если мы используем это выражение «^({line}w). +« Будем искать любую строку, которая начинается с буквы, но фиксирует начальную букву.</p>

        <p>Если бы мы захотели его получить, заменив выражение «$1» вернет начальную букву.</p>

        <p>+, *, И? Функция как квантификаторы 1 или более, 0 или более, 0 или 1 соответственно и может использоваться с группой, например ({line}w {line}d)? A, соответствует, если она находит «a» и / или если она имеет букву или число впереди.</p>


    </item>
    <item>
        <searches>
            <search element="(?:abc)" />
            <search element="(?=abc)" />
            <search element="(?!abc)" />
        </searches>
        <p>(?:abc) - это неперехваченная группа, позволяющая использовать кванторы для целой группы без необходимости их захвата, как это было бы в группе.</p>

        <p>(?=abc) Вышеуказанное совпадение истинно только в том случае, если эта группа встречается. Например, выражение {line}w + (? = {line}D +) находит буквы только в том случае, если цифры следуют.</p>

        <p>(?!abc) Отказ от предыдущей специальной группы, т. е. выполняется только предыдущее совпадение, если это не выполняется.</p>

    </item>

    <item>
        <searches>

            <search element="(?&lt;=abc)" />
            <search element="(?&lt;!abc)" />
        </searches>
        <p>(?&lt;=abc) Следующее совпадение верно только в том случае, если эта группа верна. Например, выражение (?&lt;=[A-Z])b находит букву «b» только в том случае, если предыдущая буква заглавная.</p>
        <p>(?&lt;!abc) Следующее совпадение верно только в том случае, если эта группа не соответствует действительности. Например, выражение (?&lt;![A-Z])b находит букву «b» только в том случае, если предыдущая буква не заглавная.</p>

    </item>

    <item search="|">
        <p>Он действует как логическое, например (hi|goodbye) захватывает слова «привет» или «до свидания».</p>

        <p>{line}w|{line}d захвата или буквы или числа.</p>

    </item>

    <item search="\\u0036">
        <p>Выражение, которое позволяет вам получить символ по его ascii-коду.</p>
        <p>В форме uFFFF, где F - допустимое шестнадцатеричное число (0-9 и A-F)</p>
        <p>В этом случае число 26 в шестнадцатеричном виде равно 54 в десятичном</p>
        <p>Он будет захватывать символ 4 (ascii 54)</p>
    </item>
</manual>
