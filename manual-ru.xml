<?xml version="1.0" encoding="utf-8"?>
<manual>

    <item search="c">
        <p>Самое простое выражение - искать конкретную букву или слово в тексте. Он работает, как обычный «Поиск».</p>
        <p>Например, если вы ищете букву «d», регулярное выражение будет искать эту же букву «d». Если мы ищем слово «привет», выражение будет «привет». Всё просто.</p>
    </item>
    <item search=".">
        <p>Точка в регулярном выражении определяет любой символ (число, буква, специальный символ).</p>

        <p>Если мы ищем любой символ, за которым следует буква a, например «5a», «da», «@a», шаблон будет следующим «.a».</p>

        <p>Это выражение дает многое другим, таким как группы или кванторы. Например, если мы хотим найти любые 5 символов, мы могли бы использовать «. {5}».</p>
    </item>
    <item>
        <searches>
            <search element="\\w"></search>
            <search element="\\d"></search>
            <search element="\\s"></search>
        </searches>
        <p>Регулярные выражения «\ w», «\ d», «\ s» определяют любую букву, любую цифру или пробел соответственно.</p>

        <p>Подобно точке можно определить другие выражения (группы, кванторы). Например, чтобы найти две буквы, за которыми следует пробел и число (например, «aB 3»), мы могли бы использовать это регулярное выражение «\w{2} \s \d"</p>

    </item>

    <item>
        <searches>
            <search element="\\W"></search>
            <search element="\\D"></search>
            <search element="\\S"></search>
        </searches>
        <p>Регулярные выражения «\W», «\D», «\S» определяют шаблон, в котором НЕ найдена буква, цифра или пробел.</p>

        <p>То есть он работает следующим образом, если мы ищем какой-либо символ, кроме пространства, мы могли бы использовать «\S».</p>

        <p>Например, давайте посмотрим на текст «5Q @». (Любой символ без пробела), мы могли бы использовать \ S {4}.</p>

    </item>

    <item search="[abc]">
        <p>Это выражение находит любое совпадение, которое находится внутри набора.</p>
        <p>Таким образом, выражение [bcd] находит тексты «b», «c» или «d».</p>

        <p>Вы также можете использовать выражения внутри, например [\w \d- @], вы найдете алфавитно-цифровой символ, дефис или символ «@».</p>

        <p>Как и предыдущие выражения, можно сгруппировать или использовать квантификаторы.</p>

        <p>Особое использование наборов - это диапазоны, позволяющие указать число или букву, с которой вы начинаете, и последнее. Например, [A-Z] найдет любую букву между «A» и «Z». (Для нижнего регистра вы можете использовать [a-z].</p>

        <p>Например, для поиска букв между «r» и «u» и между «c» и «e» вы можете использовать «[r-uc-e]».</p>

    </item>
    <item search="[^abc]">
        <p>Это отрицание множества, т. е. Если [abc] найдено совпадение с «a», «b» или «c». Отложенный набор [^abc] найдет любой символ, отличный от «a», «b», «c».</p>

        <p>Все установленные правила работают в отказе.</p>

    </item>
    <item>
        <searches>
            <search element="^"></search>
            <search element="$"></search>
        </searches>
        <p>Выражения «^» и «$» служат для обозначения начала и конца строки. Например, при поиске шаблона «a» вы найдете все буквы «a» в тексте, однако поиск «a$» найдет последнюю букву строки, если это a.</p>

        <p>"5a" (строка, начинающаяся с номера) -> "^\d"</p>
    </item>

    <item search="\\.">
        <p>Когда мы хотим найти символ, зарезервированный с помощью регулярного выражения, мы используем экранированный символ «\».</p>

        <p>Например, если мы хотим найти точку в конце текста, мы НЕ можем использовать «.$», Поскольку точка представляет любой символ. Таким образом, мы использовали символ Escaped, таким образом он будет выглядеть как «\.$».</p>

        <p>Например, если я хочу найти текст «\w», я бы использовал выражение «\\w».</p>

    </item>
    <item search="(abc)">
        <p>Вы можете группировать спички для вариантов замены или других утилит.</p>

        <p>Например, если мы используем это выражение «^(\w). +« Будем искать любую строку, которая начинается с буквы, но фиксирует начальную букву.</p>

        <p>Если бы мы захотели его получить, заменив выражение «$1» вернет начальную букву.</p>

        <p>+, *, И? Функция как квантификаторы 1 или более, 0 или более, 0 или 1 соответственно и может использоваться с группой, например (\w \d)? A, соответствует, если она находит «a» и / или если она имеет букву или число впереди.</p>


    </item>
    <item>
        <searches>
            <search element="(?:abc)"></search>
            <search element="(?=abc)"></search>
            <search element="(?!abc)"></search>
        </searches>
        <p>(?:abc) - это неперехваченная группа, позволяющая использовать кванторы для целой группы без необходимости их захвата, как это было бы в группе.</p>

        <p>(?=abc) Вышеуказанное совпадение истинно только в том случае, если эта группа встречается. Например, выражение \w + (? = \D +) находит буквы только в том случае, если цифры следуют.</p>

        <p>(?!abc) Отказ от предыдущей специальной группы, т. е. выполняется только предыдущее совпадение, если это не выполняется.</p>

    </item>

    <item search="|">
        <p>Он действует как логическое, например (hi|goodbye) захватывает слова «привет» или «до свидания».</p>

        <p>\w|\d захвата или буквы или числа.</p>

    </item>

    <item search="\\u0036">
        <p>Выражение, которое позволяет вам получить символ по его ascii-коду.</p>
        <p>В форме uFFFF, где F - допустимое шестнадцатеричное число (0-9 и A-F)</p>
        <p>В этом случае число 26 в шестнадцатеричном виде равно 54 в десятичном</p>
        <p>Он будет захватывать символ 4 (ascii 54)</p>
    </item>
</manual>
